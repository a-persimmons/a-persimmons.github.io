<!doctype html><html class="not-ready lg:text-base" style=--bg:#faf8f1 lang=en><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Mysql调优理论篇 - Home</title>
<meta name=theme-color><meta name=description content="关于MySQL调优理论."><meta name=author content="[柿子]"><link rel="preload stylesheet" as=style href=https://blog.codingforjoy.com/main.min.css><link rel=preload as=image href=https://blog.codingforjoy.com/theme.svg><link rel=preload as=image href="https://www.gravatar.com/avatar/ef333c1203724d1cb48104b2679529bb?s=160&amp;d=identiconf6116d89d02df33d8d90586fc2c563be?s=160&amp;d=identicon"><link rel=preload as=image href=https://blog.codingforjoy.com/github.svg><link rel=preload as=image href=https://blog.codingforjoy.com/rss.svg><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css integrity=sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js integrity=sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",()=>renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1}))</script><link rel=icon href=https://blog.codingforjoy.com/favicon.ico><link rel=apple-touch-icon href=https://blog.codingforjoy.com/apple-touch-icon.png><meta name=generator content="Hugo 0.122.0"><meta itemprop=name content="Mysql调优理论篇"><meta itemprop=description content="MySQL调优理论."><meta itemprop=datePublished content="2021-08-17T19:59:25+00:00"><meta itemprop=dateModified content="2021-08-17T19:59:25+00:00"><meta itemprop=wordCount content="1887"><meta itemprop=keywords content="Mysql,调优,"><meta property="og:title" content="Mysql调优理论篇"><meta property="og:description" content="MySQL调优理论."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.codingforjoy.com/posts/mysql%E8%B0%83%E4%BC%98%E7%90%86%E8%AE%BA%E7%AF%87/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-08-17T19:59:25+00:00"><meta property="article:modified_time" content="2021-08-17T19:59:25+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Mysql调优理论篇"><meta name=twitter:description content="MySQL调优理论."><link rel=canonical href=https://blog.codingforjoy.com/posts/mysql%E8%B0%83%E4%BC%98%E7%90%86%E8%AE%BA%E7%AF%87/></head><body class="text-black duration-200 ease-out dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-3xl px-8 lg:justify-center"><div class="relative z-50 mr-auto flex items-center"><a class="-translate-x-[1px] -translate-y-[1px] text-2xl font-semibold" href=https://blog.codingforjoy.com/>Home</a><div class="btn-dark text-[0] ml-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.svg)_left_center/cover_no-repeat] dark:invert dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 -mr-8 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#faf8f1".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"><nav class="lg:ml-12 lg:flex lg:flex-row lg:items-center lg:space-x-6"><a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/about/>About</a>
<a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/contact/>Contact</a></nav><nav class="mt-12 flex justify-center space-x-10 dark:invert lg:ml-12 lg:mt-0 lg:items-center lg:space-x-6"><a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./github.svg) href=https://github.com/a-persimmons target=_blank rel=me>github
</a><a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./rss.svg) href=https://blog.codingforjoy.com/index.xml target=_blank rel=alternate>rss</a></nav></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100%-9rem)] max-w-3xl px-8 pb-16 pt-12 dark:prose-invert"><article><header class=mb-16><h1 class="!my-0 pb-2.5">Mysql调优理论篇</h1><div class="text-sm antialiased opacity-60"><time>Aug 17, 2021</time>
<span class=mx-1>&#183;</span>
<span>[柿子]</span></div></header><section><h2 id=性能监控工具>性能监控工具</h2><h3 id=服务端的配置和性能>服务端的配置和性能</h3><h4 id=show-profile>show profile</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#f92672>#</span> <span style=color:#960050;background-color:#1e0010>案例</span>
</span></span><span style=display:flex><span><span style=color:#f92672>#</span> <span style=color:#66d9ef>all</span><span style=color:#960050;background-color:#1e0010>：显示所有性能信息</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>show</span> profile <span style=color:#66d9ef>all</span> <span style=color:#66d9ef>for</span> query n
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>#</span> block io<span style=color:#960050;background-color:#1e0010>：显示块</span>io操作的次数
</span></span><span style=display:flex><span><span style=color:#66d9ef>show</span>  profile block io <span style=color:#66d9ef>for</span> query n
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>#</span> context switches<span style=color:#960050;background-color:#1e0010>：显示上下文切换次数，被动和主动</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>show</span> profile context switches <span style=color:#66d9ef>for</span> query n
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>#</span> cpu<span style=color:#960050;background-color:#1e0010>：显示用户</span>cpu时间<span style=color:#960050;background-color:#1e0010>、系统</span>cpu时间
</span></span><span style=display:flex><span><span style=color:#66d9ef>show</span> profile cpu <span style=color:#66d9ef>for</span> query n
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>#</span> IPC<span style=color:#960050;background-color:#1e0010>：显示发送和接受的消息数量</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>show</span> profile ipc <span style=color:#66d9ef>for</span> query n
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>#</span> page faults<span style=color:#960050;background-color:#1e0010>：显示页错误数量</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>show</span> profile page faults <span style=color:#66d9ef>for</span> query n
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>#</span> <span style=color:#66d9ef>source</span><span style=color:#960050;background-color:#1e0010>：显示源码中的函数名称与位置</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>show</span> profile <span style=color:#66d9ef>source</span> <span style=color:#66d9ef>for</span> query n
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>#</span> swaps<span style=color:#960050;background-color:#1e0010>：显示</span>swap的次数
</span></span><span style=display:flex><span><span style=color:#66d9ef>show</span> profile swaps <span style=color:#66d9ef>for</span> query n
</span></span></code></pre></div><h3 id=运行时性能>运行时性能</h3><h4 id=performance_schema>performance_schema</h4><h5 id=简介>简介</h5><ul><li>它是数据库中的库，使用的存储引擎是performance_schema，主要关注的是数据库运行过程中的性能相关的数据，与<code>information_schema</code>不同，关注的是数据库表的元数据</li><li>server内部在发生<code>函数调用</code>、<code>操作系统的等待</code>、<code>SQL语句的执行阶段</code>、<code>单个SQL或者多个SQL的集合</code>的事件来触发采集<code>消耗</code>、<code>耗时</code>、<code>活动执行次数</code>等信息，并且事件的采集可以方便的提供server中的相关存储引擎对<code>磁盘文件</code>、<code>表I/O</code>、<code>表锁</code>等资源同步多用相关信息</li><li>它的记录只会在server本地，不会记录到binlog，同时也不复制到其他的server，其实在mysql源代码实现过程中主要是通过检查点（埋点）的方式收集</li><li>可以通过select查询，同时也还可以修改相关收集配置，动态修改<code>setup_*</code>开头的几个配置表</li></ul><h5 id=表分类>表分类</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- 事件表：当前语句、历史语句、长语句历史、聚合后的摘要summary
</span></span></span><span style=display:flex><span><span style=color:#75715e>-- 其中，summary表还可以根据帐号(account),主机(host),程序(program),
</span></span></span><span style=display:flex><span><span style=color:#75715e>-- 线程(thread),用户(user)和全局(global)再进行细分)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>show</span> tables <span style=color:#66d9ef>like</span> <span style=color:#e6db74>&#39;%statement%&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 等待事件记录表，与语句事件类型的相关记录表类似：
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>show</span> tables <span style=color:#66d9ef>like</span> <span style=color:#e6db74>&#39;%wait%&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 阶段事件记录表，记录语句执行的阶段事件的表
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>show</span> tables <span style=color:#66d9ef>like</span> <span style=color:#e6db74>&#39;%stage%&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 事务事件记录表，记录事务相关的事件的表
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>show</span> tables <span style=color:#66d9ef>like</span> <span style=color:#e6db74>&#39;%transaction%&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 监控文件系统层调用的表
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>show</span> tables <span style=color:#66d9ef>like</span> <span style=color:#e6db74>&#39;%file%&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 监视内存使用的表
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>show</span> tables <span style=color:#66d9ef>like</span> <span style=color:#e6db74>&#39;%memory%&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 动态对performance_schema进行配置的配置表
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>show</span> tables <span style=color:#66d9ef>like</span> <span style=color:#e6db74>&#39;%setup%&#39;</span>;
</span></span></code></pre></div><h5 id=入门使用>入门使用</h5><p>首先需要查看是否开启此功能，需要显示的修改[my.cnf]配置文件</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- 查看performance_schema的属性
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>mysql<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>SHOW</span> VARIABLES <span style=color:#66d9ef>LIKE</span> <span style=color:#e6db74>&#39;performance_schema&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#f92672>+</span><span style=color:#75715e>--------------------+-------+
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>|</span> Variable_name      <span style=color:#f92672>|</span> Value <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span><span style=color:#f92672>+</span><span style=color:#75715e>--------------------+-------+
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>|</span> performance_schema <span style=color:#f92672>|</span> <span style=color:#66d9ef>ON</span>    <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span><span style=color:#f92672>+</span><span style=color:#75715e>--------------------+-------+
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>1</span> <span style=color:#66d9ef>row</span> <span style=color:#66d9ef>in</span> <span style=color:#66d9ef>set</span> (<span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>01</span> sec)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 在配置文件中修改performance_schema的属性值，on表示开启，off表示关闭
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>[mysqld]
</span></span><span style=display:flex><span>performance_schema<span style=color:#f92672>=</span><span style=color:#66d9ef>ON</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 切换数据库
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>use performance_schema;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 查看当前数据库下的所有表,会看到有很多表存储着相关的信息
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>show</span> tables;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 可以通过show create table tablename来查看创建表的时候的表结构
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>mysql<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>show</span> <span style=color:#66d9ef>create</span> <span style=color:#66d9ef>table</span> setup_consumers;
</span></span><span style=display:flex><span><span style=color:#f92672>+</span><span style=color:#75715e>-----------------+---------------------------------
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>|</span> <span style=color:#66d9ef>Table</span>           <span style=color:#f92672>|</span> <span style=color:#66d9ef>Create</span> <span style=color:#66d9ef>Table</span>                    
</span></span><span style=display:flex><span><span style=color:#f92672>+</span><span style=color:#75715e>-----------------+---------------------------------
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>|</span> setup_consumers <span style=color:#f92672>|</span> <span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> <span style=color:#f92672>`</span>setup_consumers<span style=color:#f92672>`</span> (
</span></span><span style=display:flex><span>  <span style=color:#f92672>`</span>NAME<span style=color:#f92672>`</span> varchar(<span style=color:#ae81ff>64</span>) <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,                      
</span></span><span style=display:flex><span>  <span style=color:#f92672>`</span>ENABLED<span style=color:#f92672>`</span> enum(<span style=color:#e6db74>&#39;YES&#39;</span>,<span style=color:#e6db74>&#39;NO&#39;</span>) <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>               
</span></span><span style=display:flex><span>) ENGINE<span style=color:#f92672>=</span>PERFORMANCE_SCHEMA <span style=color:#66d9ef>DEFAULT</span> CHARSET<span style=color:#f92672>=</span>utf8 <span style=color:#f92672>|</span>  
</span></span><span style=display:flex><span><span style=color:#f92672>+</span><span style=color:#75715e>-----------------+---------------------------------
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>1</span> <span style=color:#66d9ef>row</span> <span style=color:#66d9ef>in</span> <span style=color:#66d9ef>set</span> (<span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>00</span> sec) 
</span></span></code></pre></div><h5 id=两个概念>两个概念</h5><ul><li>instruments：生产者，用于采集mysql中各种各样的操作产生的事件信息，对应配置表中的配置项我们可以称为监控采集配置项，前面动态表<code>setup_*配置</code></li><li>consumers：消费者，对应的消费者表用于存储来自instruments采集的数据，对应配置表中的配置项我们可以称为消费存储配置项</li></ul><h5 id=常用配置项>常用配置项</h5><h6 id=启动配置>启动配置</h6><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 是否在mysql server启动时就开启events_statements_current表的记录功能(该表记录当前的语句事件信息)，</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 启动之后也可以在setup_consumers表中使用UPDATE语句进行动态更新setup_consumers配置</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 表中的events_statements_current配置项，默认值为TRUE</span>
</span></span><span style=display:flex><span>performance_schema_consumer_events_statements_current<span style=color:#f92672>=</span>TRUE
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 与performance_schema_consumer_events_statements_current选项类似，</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 但该选项是用于配置是否记录语句事件短历史信息，默认为TRUE</span>
</span></span><span style=display:flex><span>performance_schema_consumer_events_statements_history<span style=color:#f92672>=</span>TRUE
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 与performance_schema_consumer_events_statements_current选项类似，</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 但该选项是用于配置是否记录语句事件长历史信息，默认为FALSE</span>
</span></span><span style=display:flex><span>performance_schema_consumer_events_stages_history_long<span style=color:#f92672>=</span>FALSE
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 除了statement(语句)事件之外，还支持：wait(等待)事件、state(阶段)事件、transaction(事务)事件，</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 他们与statement事件一样都有三个启动项分别进行配置，但这些等待事件默认未启用，</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 如果需要在MySQL Server启动时一同启动，则通常需要写进my.cnf配置文件中</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 是否在MySQL Server启动时就开启全局表（如：</span>
</span></span><span style=display:flex><span><span style=color:#75715e># mutex_instances、rwlock_instances、cond_instances、file_instances、</span>
</span></span><span style=display:flex><span><span style=color:#75715e># users、hostsaccounts、socket_summary_by_event_name、file_summary_by_instance</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 等大部分的全局对象计数统计和事件汇总统计信息表 ）的记录功能，</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 启动之后也可以在setup_consumers表中使用UPDATE语句进行动态更新全局配置项,默认值为TRUE</span>
</span></span><span style=display:flex><span>performance_schema_consumer_global_instrumentation<span style=color:#f92672>=</span>TRUE
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 是否在MySQL Server启动时就开启events_statements_summary_by_digest 表的记录功能，</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 启动之后也可以在setup_consumers表中使用UPDATE语句进行动态更新digest配置项,默认值为TRUE</span>
</span></span><span style=display:flex><span>performance_schema_consumer_statements_digest<span style=color:#f92672>=</span>TRUE
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 是否在MySQL Server启动时就开启</span>
</span></span><span style=display:flex><span>performance_schema_consumer_thread_instrumentation<span style=color:#f92672>=</span>TRUE
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># events_xxx_summary_by_yyy_by_event_name表的记录功能，</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 启动之后也可以在setup_consumers表中使用UPDATE语句进行动态更新线程配置项,默认值为TRUE</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>performance_schema_instrument<span style=color:#f92672>[=</span>name<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 是否在MySQL Server启动时就启用某些采集器，由于instruments配置项多达数千个，</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 所以该配置项支持key-value模式，还支持%号进行通配等，如下:</span>
</span></span><span style=display:flex><span><span style=color:#75715e># [=name]可以指定为具体的Instruments名称（但是这样如果有多个需要指定的时候，就需要使用该选项多次），</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 也可以使用通配符，可以指定instruments相同的前缀+通配符，</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 也可以使用%代表所有的instruments指定开启单个instruments</span>
</span></span><span style=display:flex><span>performance-schema-instrument<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;instrument_name=value&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 使用通配符指定开启多个instruments</span>
</span></span><span style=display:flex><span>performance-schema-instrument<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;wait/synch/cond/%=COUNTED&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 开关所有的instruments</span>
</span></span><span style=display:flex><span>performance-schema-instrument<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;%=ON&#39;</span>
</span></span><span style=display:flex><span>performance-schema-instrument<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;%=OFF&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 注意，这些启动选项要生效的前提是，需要设置performance_schema=ON。</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 另外，这些启动选项虽然无法使用show variables语句查看，</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 但我们可以通过setup_instruments和setup_consumers表查询这些选项指定的值。</span>
</span></span></code></pre></div><h6 id=系统变量>系统变量</h6><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 查询是否开启运行时事件记录功能</span>
</span></span><span style=display:flex><span>show variables like <span style=color:#e6db74>&#39;%performance_schema%&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#75715e># 重要的属性解释</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 控制performance_schema功能的开关，要使用MySQL的performance_schema，需要在mysqld启动时启用，以启用事件收集功能，该参数</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 在5.7.x之前支持performance_schema的版本中默认关闭，5.7.x版本开始默认开启</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 注意：如果mysqld在初始化performance_schema时发现无法分配任何相关的内部缓冲区，则performance_schema将自动禁用，并将performance_schema设置为OFF</span>
</span></span><span style=display:flex><span>performance_schema<span style=color:#f92672>=</span>ON
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 控制events_statements_summary_by_digest表中的最大行数。如果产生的语句摘要信息超过此最大值，</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 便无法继续存入该表，此时performance_schema会增加状态变量</span>
</span></span><span style=display:flex><span>performance_schema_digests_size<span style=color:#f92672>=</span><span style=color:#ae81ff>10000</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 控制events_statements_history_long表中的最大行数，</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 该参数控制所有会话在events_statements_history_long表中能够存放的</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 总事件记录数，超过这个限制之后，最早的记录将被覆盖全局变量，</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 只读变量，整型值，5.6.3版本引入 * 5.6.x版本中，5.6.5及其之前的版</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 本默认为10000，5.6.6及其之后的版本默认值为-1，通常情况下，</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 自动计算的值都是10000 * 5.7.x版本中，默认值为-1，通常情况下，自动</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 计算的值都是10000</span>
</span></span><span style=display:flex><span>performance_schema_events_statements_history_long_size<span style=color:#f92672>=</span><span style=color:#ae81ff>10000</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 控制events_statements_history表中单个线程（会话）的最大行数，该参数控制单个会话在</span>
</span></span><span style=display:flex><span><span style=color:#75715e># events_statements_history表中能够存放的事件记录数，超过这个限制之后，单个会话最早的记录将被覆盖</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 全局变量，只读变量，整型值，5.6.3版本引入 * 5.6.x版本中，5.6.5及其之前的版本默认为10，5.6.6及其之后的版本默认值为-1，</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 通常情况下，自动计算的值都是10 * 5.7.x版本中，默认值为-1，通常情况下，自动计算的值都是10</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 除了statement(语句)事件之外，wait(等待)事件、state(阶段)事件、transaction(事务)事件，</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 他们与statement事件一样都有三个参数分别进行存储限制配置，有兴趣的同学自行研究，这里不再赘述</span>
</span></span><span style=display:flex><span>performance_schema_events_statements_history_size<span style=color:#f92672>=</span><span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 用于控制标准化形式的SQL语句文本在存入performance_schema时的限制长度，</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 该变量与max_digest_length变量相关(max_digest_length变量含义请自行查阅相关资料)全局变量，</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 只读变量，默认值1024字节，整型值，取值范围0~1048576</span>
</span></span><span style=display:flex><span>performance_schema_max_digest_length<span style=color:#f92672>=</span><span style=color:#ae81ff>1024</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 控制存入events_statements_current，events_statements_history和events_statements_history_long语句事件表中的</span>
</span></span><span style=display:flex><span><span style=color:#75715e># SQL_TEXT列的最大SQL长度字节数。 超出系统变量performance_schema_max_sql_text_length的部分将被丢弃，不会记录，一般情况</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 下不需要调整该参数，除非被截断的部分与其他SQL比起来有很大差异</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 全局变量，只读变量，整型值，默认值为1024字节，取值范围为0~1048576，5.7.6版本引入</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 降低系统变量performance_schema_max_sql_text_length值可以减少内存使用，但如果汇总的SQL中，被截断部分有较大差异，会导致没</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 有办法再对这些有较大差异的SQL进行区分。 增加该系统变量值会增加内存使用，但对于汇总SQL来讲可以更精准地区分不同的部分。</span>
</span></span><span style=display:flex><span>performance_schema_max_sql_text_length<span style=color:#f92672>=</span><span style=color:#ae81ff>1024</span>
</span></span></code></pre></div><h5 id=setup_配置表说明>setup_*配置表说明</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>performance_timers表中记录了server中有哪些可用的事件计时器
</span></span></span><span style=display:flex><span><span style=color:#75715e>字段解释：
</span></span></span><span style=display:flex><span><span style=color:#75715e>	timer_name:表示可用计时器名称，CYCLE是基于CPU周期计数器的定时器
</span></span></span><span style=display:flex><span><span style=color:#75715e>	timer_frequency:表示每秒钟对应的计时器单位的数量,CYCLE计时器的换算值与CPU的频率相关、
</span></span></span><span style=display:flex><span><span style=color:#75715e>	timer_resolution:计时器精度值，表示在每个计时器被调用时额外增加的值
</span></span></span><span style=display:flex><span><span style=color:#75715e>	timer_overhead:表示在使用定时器获取事件时开销的最小周期值
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>select</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>from</span> performance_timers;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>setup_timers表中记录当前使用的事件计时器信息
</span></span></span><span style=display:flex><span><span style=color:#75715e>字段解释：
</span></span></span><span style=display:flex><span><span style=color:#75715e>	name:计时器类型，对应某个事件类别
</span></span></span><span style=display:flex><span><span style=color:#75715e>	timer_name:计时器类型名称
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>select</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>from</span> setup_timers;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>setup_consumers表中列出了consumers可配置列表项
</span></span></span><span style=display:flex><span><span style=color:#75715e>字段解释：
</span></span></span><span style=display:flex><span><span style=color:#75715e>	NAME：consumers配置名称
</span></span></span><span style=display:flex><span><span style=color:#75715e>	ENABLED：consumers是否启用，有效值为YES或NO，此列可以使用UPDATE语句修改。
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>select</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>from</span> setup_consumers;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>setup_instruments 表列出了instruments 列表配置项，即代表了哪些事件支持被收集：
</span></span></span><span style=display:flex><span><span style=color:#75715e>字段解释：
</span></span></span><span style=display:flex><span><span style=color:#75715e>	NAME：instruments名称，instruments名称可能具有多个部分并形成层次结构
</span></span></span><span style=display:flex><span><span style=color:#75715e>	ENABLED：instrumetns是否启用，有效值为YES或NO，此列可以使用UPDATE语句修改。如果设置为NO，则这个instruments不会被执行，
</span></span></span><span style=display:flex><span><span style=color:#75715e>	不会产生任何的事件信息
</span></span></span><span style=display:flex><span><span style=color:#75715e>	TIMED：instruments是否收集时间信息，有效值为YES或NO，此列可以使用UPDATE语句修改，如果设置为NO，则这个instruments不会收
</span></span></span><span style=display:flex><span><span style=color:#75715e>	集时间信息
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> setup_instruments;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>setup_actors表的初始内容是匹配任何用户和主机，因此对于所有前台线程，默认情况下启用监视和历史事件收集功能
</span></span></span><span style=display:flex><span><span style=color:#75715e>字段解释：
</span></span></span><span style=display:flex><span><span style=color:#75715e>	HOST：与grant语句类似的主机名，一个具体的字符串名字，或使用“％”表示“任何主机”
</span></span></span><span style=display:flex><span><span style=color:#75715e>	USER：一个具体的字符串名称，或使用“％”表示“任何用户”
</span></span></span><span style=display:flex><span><span style=color:#75715e>	ROLE：当前未使用，MySQL 8.0中才启用角色功能
</span></span></span><span style=display:flex><span><span style=color:#75715e>	ENABLED：是否启用与HOST，USER，ROLE匹配的前台线程的监控功能，有效值为：YES或NO
</span></span></span><span style=display:flex><span><span style=color:#75715e>	HISTORY：是否启用与HOST， USER，ROLE匹配的前台线程的历史事件记录功能，有效值为：YES或NO
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> setup_actors;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>setup_objects表控制performance_schema是否监视特定对象。默认情况下，此表的最大行数为100行。
</span></span></span><span style=display:flex><span><span style=color:#75715e>字段解释：
</span></span></span><span style=display:flex><span><span style=color:#75715e>	OBJECT_TYPE：instruments类型，有效值为：“EVENT”（事件调度器事件）、“FUNCTION”（存储函数）、“PROCEDURE”（存储过程）、
</span></span></span><span style=display:flex><span><span style=color:#75715e>	“TABLE”（基表）、“TRIGGER”（触发器），TABLE对象类型的配置会影响表I/O事件（wait/io/table/sql/handler instrument）和
</span></span></span><span style=display:flex><span><span style=color:#75715e>	表锁事件（wait/lock/table/sql/handler instrument）的收集
</span></span></span><span style=display:flex><span><span style=color:#75715e>	OBJECT_SCHEMA：某个监视类型对象涵盖的数据库名称，一个字符串名称，或“％”(表示“任何数据库”)
</span></span></span><span style=display:flex><span><span style=color:#75715e>	OBJECT_NAME：某个监视类型对象涵盖的表名，一个字符串名称，或“％”(表示“任何数据库内的对象”)
</span></span></span><span style=display:flex><span><span style=color:#75715e>	ENABLED：是否开启对某个类型对象的监视功能，有效值为：YES或NO。此列可以修改
</span></span></span><span style=display:flex><span><span style=color:#75715e>	TIMED：是否开启对某个类型对象的时间收集功能，有效值为：YES或NO，此列可以修改
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> setup_objects;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>threads表对于每个server线程生成一行包含线程相关的信息，
</span></span></span><span style=display:flex><span><span style=color:#75715e>字段解释：
</span></span></span><span style=display:flex><span><span style=color:#75715e>	THREAD_ID：线程的唯一标识符（ID）
</span></span></span><span style=display:flex><span><span style=color:#75715e>	NAME：与server中的线程检测代码相关联的名称(注意，这里不是instruments名称)
</span></span></span><span style=display:flex><span><span style=color:#75715e>	TYPE：线程类型，有效值为：FOREGROUND、BACKGROUND。分别表示前台线程和后台线程
</span></span></span><span style=display:flex><span><span style=color:#75715e>	PROCESSLIST_ID：对应INFORMATION_SCHEMA.PROCESSLIST表中的ID列。
</span></span></span><span style=display:flex><span><span style=color:#75715e>	PROCESSLIST_USER：与前台线程相关联的用户名，对于后台线程为NULL。
</span></span></span><span style=display:flex><span><span style=color:#75715e>	PROCESSLIST_HOST：与前台线程关联的客户端的主机名，对于后台线程为NULL。
</span></span></span><span style=display:flex><span><span style=color:#75715e>	PROCESSLIST_DB：线程的默认数据库，如果没有，则为NULL。
</span></span></span><span style=display:flex><span><span style=color:#75715e>	PROCESSLIST_COMMAND：对于前台线程，该值代表着当前客户端正在执行的command类型，如果是sleep则表示当前会话处于空闲状态
</span></span></span><span style=display:flex><span><span style=color:#75715e>	PROCESSLIST_TIME：当前线程已处于当前线程状态的持续时间（秒）
</span></span></span><span style=display:flex><span><span style=color:#75715e>	PROCESSLIST_STATE：表示线程正在做什么事情。
</span></span></span><span style=display:flex><span><span style=color:#75715e>	PROCESSLIST_INFO：线程正在执行的语句，如果没有执行任何语句，则为NULL。
</span></span></span><span style=display:flex><span><span style=color:#75715e>	PARENT_THREAD_ID：如果这个线程是一个子线程（由另一个线程生成），那么该字段显示其父线程ID
</span></span></span><span style=display:flex><span><span style=color:#75715e>	ROLE：暂未使用
</span></span></span><span style=display:flex><span><span style=color:#75715e>	INSTRUMENTED：线程执行的事件是否被检测。有效值：YES、NO 
</span></span></span><span style=display:flex><span><span style=color:#75715e>	HISTORY：是否记录线程的历史事件。有效值：YES、NO * 
</span></span></span><span style=display:flex><span><span style=color:#75715e>	THREAD_OS_ID：由操作系统层定义的线程或任务标识符（ID）：
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>select</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>from</span> threads
</span></span></code></pre></div><h5 id=实践案例>实践案例</h5><p>了解相关的参数配置后，可以对表进行一些实际分析，</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- 1、哪类的SQL执行最多？
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>SELECT</span> DIGEST_TEXT,COUNT_STAR,FIRST_SEEN,LAST_SEEN <span style=color:#66d9ef>FROM</span> events_statements_summary_by_digest <span style=color:#66d9ef>ORDER</span> <span style=color:#66d9ef>BY</span> COUNT_STAR <span style=color:#66d9ef>DESC</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 2、哪类SQL的平均响应时间最多？
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>SELECT</span> DIGEST_TEXT,AVG_TIMER_WAIT <span style=color:#66d9ef>FROM</span> events_statements_summary_by_digest <span style=color:#66d9ef>ORDER</span> <span style=color:#66d9ef>BY</span> COUNT_STAR <span style=color:#66d9ef>DESC</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 3、哪类SQL排序记录数最多？
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>SELECT</span> DIGEST_TEXT,SUM_SORT_ROWS <span style=color:#66d9ef>FROM</span> events_statements_summary_by_digest <span style=color:#66d9ef>ORDER</span> <span style=color:#66d9ef>BY</span> COUNT_STAR <span style=color:#66d9ef>DESC</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 4、哪类SQL扫描记录数最多？
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>SELECT</span> DIGEST_TEXT,SUM_ROWS_EXAMINED <span style=color:#66d9ef>FROM</span> events_statements_summary_by_digest <span style=color:#66d9ef>ORDER</span> <span style=color:#66d9ef>BY</span> COUNT_STAR <span style=color:#66d9ef>DESC</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 5、哪类SQL使用临时表最多？
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>SELECT</span> DIGEST_TEXT,SUM_CREATED_TMP_TABLES,SUM_CREATED_TMP_DISK_TABLES <span style=color:#66d9ef>FROM</span> events_statements_summary_by_digest <span style=color:#66d9ef>ORDER</span> <span style=color:#66d9ef>BY</span> COUNT_STAR <span style=color:#66d9ef>DESC</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 6、哪类SQL返回结果集最多？
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>SELECT</span> DIGEST_TEXT,SUM_ROWS_SENT <span style=color:#66d9ef>FROM</span> events_statements_summary_by_digest <span style=color:#66d9ef>ORDER</span> <span style=color:#66d9ef>BY</span> COUNT_STAR <span style=color:#66d9ef>DESC</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 7、哪个表物理IO最多？
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>SELECT</span> file_name,event_name,SUM_NUMBER_OF_BYTES_READ,SUM_NUMBER_OF_BYTES_WRITE <span style=color:#66d9ef>FROM</span> file_summary_by_instance <span style=color:#66d9ef>ORDER</span> <span style=color:#66d9ef>BY</span> SUM_NUMBER_OF_BYTES_READ <span style=color:#f92672>+</span> SUM_NUMBER_OF_BYTES_WRITE <span style=color:#66d9ef>DESC</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 8、哪个表逻辑IO最多？
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>SELECT</span> object_name,COUNT_READ,COUNT_WRITE,COUNT_FETCH,SUM_TIMER_WAIT <span style=color:#66d9ef>FROM</span> table_io_waits_summary_by_table <span style=color:#66d9ef>ORDER</span> <span style=color:#66d9ef>BY</span> sum_timer_wait <span style=color:#66d9ef>DESC</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 9、哪个索引访问最多？
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>SELECT</span> OBJECT_NAME,INDEX_NAME,COUNT_FETCH,COUNT_INSERT,COUNT_UPDATE,COUNT_DELETE <span style=color:#66d9ef>FROM</span> table_io_waits_summary_by_index_usage <span style=color:#66d9ef>ORDER</span> <span style=color:#66d9ef>BY</span> SUM_TIMER_WAIT <span style=color:#66d9ef>DESC</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 10、哪个索引从来没有用过？
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>SELECT</span> OBJECT_SCHEMA,OBJECT_NAME,INDEX_NAME <span style=color:#66d9ef>FROM</span> table_io_waits_summary_by_index_usage <span style=color:#66d9ef>WHERE</span> INDEX_NAME <span style=color:#66d9ef>IS</span> <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span> <span style=color:#66d9ef>AND</span> COUNT_STAR <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>AND</span> OBJECT_SCHEMA <span style=color:#f92672>&lt;&gt;</span> <span style=color:#e6db74>&#39;mysql&#39;</span> <span style=color:#66d9ef>ORDER</span> <span style=color:#66d9ef>BY</span> OBJECT_SCHEMA,OBJECT_NAME;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 11、哪个等待事件消耗时间最多？
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>SELECT</span> EVENT_NAME,COUNT_STAR,SUM_TIMER_WAIT,AVG_TIMER_WAIT <span style=color:#66d9ef>FROM</span> events_waits_summary_global_by_event_name <span style=color:#66d9ef>WHERE</span> event_name <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#39;idle&#39;</span> <span style=color:#66d9ef>ORDER</span> <span style=color:#66d9ef>BY</span> SUM_TIMER_WAIT <span style=color:#66d9ef>DESC</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 12-1、剖析某条SQL的执行情况，包括statement信息，stege信息，wait信息
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>SELECT</span> EVENT_ID,sql_text <span style=color:#66d9ef>FROM</span> events_statements_history <span style=color:#66d9ef>WHERE</span> sql_text <span style=color:#66d9ef>LIKE</span> <span style=color:#e6db74>&#39;%count(*)%&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 12-2、查看每个阶段的时间消耗
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>SELECT</span> event_id,EVENT_NAME,<span style=color:#66d9ef>SOURCE</span>,TIMER_END <span style=color:#f92672>-</span> TIMER_START <span style=color:#66d9ef>FROM</span> events_stages_history_long <span style=color:#66d9ef>WHERE</span> NESTING_EVENT_ID <span style=color:#f92672>=</span> <span style=color:#ae81ff>1553</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 12-3、查看每个阶段的锁等待情况
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>SELECT</span> event_id,event_name,<span style=color:#66d9ef>source</span>,timer_wait,object_name,index_name,<span style=color:#66d9ef>operation</span>,nesting_event_id <span style=color:#66d9ef>FROM</span> events_waits_history_longWHERE nesting_event_id <span style=color:#f92672>=</span> <span style=color:#ae81ff>1553</span>;
</span></span></code></pre></div><p><a href=https://dev.mysql.com/doc/refman/5.7/en/performance-schema.html>参考官方performance_schema教程</a></p><h3 id=show-processlist>show processlist</h3><p>当前由服务器内执行的线程集执行的操作情况，更多可以参考官网：<a href=https://dev.mysql.com/doc/refman/5.7/en/processlist-access.html#processlist-sources>Sources of Process Information</a></p><h2 id=sechema与数据类型优化>Sechema与数据类型优化</h2><h3 id=数据类型优化>数据类型优化</h3><ul><li><p>三原则：占用越小越好，足够简单，避免为null</p></li><li><p>实际操作建议</p><ul><li><p>整型：TINYINT，SMALLEST，MEDIUMINT，INT，BIGINT分别使用8，16，24，32，64位存储空间</p></li><li><p>字符和字符串：char（255字）、vachar（65535字）、text类（TINYTEXT:2^8^-1、TEXT:2^16^ -1、MEDIUMTEXT:2^24^-1、LONGTEXT:4G或2^32^-1）单位字节</p></li><li><p>BLOB和TEXT类型，分别是二进制和字符串格式来存储</p></li><li><p>datatime和timestamp</p><ul><li>datatime（8字节）<ul><li>与时区无关，数据库底层对datetime无效</li><li>可以精确到毫秒</li><li>可保存的范围大</li><li><code>字符串存储会导致确实时间的精度</code></li></ul></li><li>date（3字节）<ul><li>占用的字节数比字符串、datatime、int少</li><li>可以通过date类型进行日期计算</li><li>保存范围是1000-01-01到9999-12-31</li></ul></li><li>timestamp（4字节）<ul><li>时间范围是linux元年1970-01-01开始到2038-01-19</li><li>精确到秒</li><li>采用整型存储</li><li>依赖数据库的时区</li><li>自动更新timestamp的列值</li></ul></li></ul></li><li><p>尝试使用枚举代替字符串，mysql存储枚举类型非常的紧凑，有利于提升IO读取</p></li><li><p>存储特殊类型通过可以通过函数转换如IP存储</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>	<span style=color:#f92672>#</span> <span style=color:#960050;background-color:#1e0010>序列化</span>
</span></span><span style=display:flex><span> mysql<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>select</span> inet_aton(<span style=color:#e6db74>&#39;1.1.1.1&#39;</span>);
</span></span><span style=display:flex><span> <span style=color:#f92672>+</span><span style=color:#75715e>----------------------+
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> <span style=color:#f92672>|</span> inet_aton(<span style=color:#e6db74>&#39;1.1.1.1&#39;</span>) <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>+</span><span style=color:#75715e>----------------------+
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> <span style=color:#f92672>|</span>             <span style=color:#ae81ff>16843009</span> <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>+</span><span style=color:#75715e>----------------------+
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>row</span> <span style=color:#66d9ef>in</span> <span style=color:#66d9ef>set</span> (<span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>00</span> sec)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#f92672>#</span> <span style=color:#960050;background-color:#1e0010>反序列化</span>
</span></span><span style=display:flex><span> mysql<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>select</span> inet_ntoa(<span style=color:#ae81ff>16843009</span>);
</span></span><span style=display:flex><span> <span style=color:#f92672>+</span><span style=color:#75715e>---------------------+
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> <span style=color:#f92672>|</span> inet_ntoa(<span style=color:#ae81ff>16843009</span>) <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>+</span><span style=color:#75715e>---------------------+
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> <span style=color:#f92672>|</span> <span style=color:#ae81ff>1</span>.<span style=color:#ae81ff>1</span>.<span style=color:#ae81ff>1</span>.<span style=color:#ae81ff>1</span>             <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>+</span><span style=color:#75715e>---------------------+
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>row</span> <span style=color:#66d9ef>in</span> <span style=color:#66d9ef>set</span> (<span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>00</span> sec)
</span></span></code></pre></div></li></ul></li></ul><h3 id=合理的范式和反范式>合理的范式和反范式</h3><ul><li>合理的范式<ul><li>优点：更新更快，基本不会出现重复的数据，在内存中操作比较快</li><li>缺点：需要不断的关联，增加IO消耗</li></ul></li><li>反范式<ul><li>优点：所有的信息都在一张表中，可以避免关联，减少IO消耗</li><li>缺点：冗余较多，删除操作时会删除不必要信息</li></ul></li><li>实践<ul><li>项目前：先范式设计后分析业务反范式冗余存储，更新优先级根据业务来看（及时和延迟）</li><li>项目中：分析业务代码逻辑，是否需要优化数据表增加冗余字段减少IO的开销</li></ul></li></ul><h3 id=主键选择>主键选择</h3><ul><li><p>代理主键</p><ul><li>与业务无关，无意义的数字序列，如ID</li></ul></li><li><p>自然主键</p><ul><li>和业务相关，事物属性唯一标识，如身份证</li></ul></li><li><p>如何选择</p><ul><li>代理主键更好，不与业务耦合，更加容易维护，统一的策略，也减少源代码数量</li></ul></li></ul><h3 id=字符集选择>字符集选择</h3><p>mysql精确到字段取优化，合适的字符集，一定程度上也会减少IO</p><ul><li>latin*：纯拉丁内容适合</li><li>utf-8*：多语言内容</li></ul><h3 id=存储引擎选择>存储引擎选择</h3><p><img src=https://i.loli.net/2021/08/19/YcgjQklxv6XGoMq.png alt=image-20210817232400702></p><h3 id=适当的拆分>适当的拆分</h3><ul><li>比如有字段类型为TEXT之类大型字段，可以尝试拆到单独的表，当查询不需要此字段的查询是，可以大大减少IO的处理时间</li></ul><h2 id=执行计划explain>执行计划EXPLAIN</h2><h3 id=格式explain--sql>格式：explain + SQL</h3><h3 id=explain字段解析>EXPLAIN字段解析</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>mysql<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>explain</span> <span style=color:#66d9ef>select</span> inet_aton(<span style=color:#e6db74>&#39;1.1.1.1&#39;</span>)<span style=color:#960050;background-color:#1e0010>\</span><span style=color:#66d9ef>G</span>
</span></span><span style=display:flex><span><span style=color:#f92672>***************************</span> <span style=color:#ae81ff>1</span>. <span style=color:#66d9ef>row</span> <span style=color:#f92672>***************************</span>
</span></span><span style=display:flex><span>           id: <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>  select_type: <span style=color:#66d9ef>SIMPLE</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>table</span>: <span style=color:#66d9ef>NULL</span>
</span></span><span style=display:flex><span>   partitions: <span style=color:#66d9ef>NULL</span>
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>type</span>: <span style=color:#66d9ef>NULL</span>
</span></span><span style=display:flex><span>possible_keys: <span style=color:#66d9ef>NULL</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>key</span>: <span style=color:#66d9ef>NULL</span>
</span></span><span style=display:flex><span>      key_len: <span style=color:#66d9ef>NULL</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>ref</span>: <span style=color:#66d9ef>NULL</span>
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>rows</span>: <span style=color:#66d9ef>NULL</span>
</span></span><span style=display:flex><span>     filtered: <span style=color:#66d9ef>NULL</span>
</span></span><span style=display:flex><span>        Extra: <span style=color:#66d9ef>No</span> tables used
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span> <span style=color:#66d9ef>row</span> <span style=color:#66d9ef>in</span> <span style=color:#66d9ef>set</span>, <span style=color:#ae81ff>1</span> warning (<span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>00</span> sec)
</span></span></code></pre></div><h4 id=id有三种情况>id有三种情况</h4><ol><li>id相同，顺序执行</li><li>id不同，递增，id号越大，越先执行</li><li>id相同和id不同同时存在，即第一种和第二种结合</li></ol><h4 id=select_type>select_type</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- sample:简单的查询，不包含子查询和union
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>explain</span> <span style=color:#66d9ef>select</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>from</span> emp;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- primary:查询中若包含任何复杂的子查询，最外层查询则被标记为Primary
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>explain</span> <span style=color:#66d9ef>select</span> staname,ename supname <span style=color:#66d9ef>from</span> (<span style=color:#66d9ef>select</span> ename staname,mgr <span style=color:#66d9ef>from</span> emp) t <span style=color:#66d9ef>join</span> emp <span style=color:#66d9ef>on</span> t.mgr<span style=color:#f92672>=</span>emp.empno ;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- union:若第二个select出现在union之后，则被标记为union
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>explain</span> <span style=color:#66d9ef>select</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>from</span> emp <span style=color:#66d9ef>where</span> deptno <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span> <span style=color:#66d9ef>union</span> <span style=color:#66d9ef>select</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>from</span> emp <span style=color:#66d9ef>where</span> sal <span style=color:#f92672>&gt;</span><span style=color:#ae81ff>2000</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- dependent union:跟union类似，此处的depentent表示union或union all联合而成的结果会受外部表影响
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>explain</span> <span style=color:#66d9ef>select</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>from</span> emp e <span style=color:#66d9ef>where</span> e.empno  <span style=color:#66d9ef>in</span> ( <span style=color:#66d9ef>select</span> empno <span style=color:#66d9ef>from</span> emp <span style=color:#66d9ef>where</span> deptno <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span> <span style=color:#66d9ef>union</span> <span style=color:#66d9ef>select</span> empno <span style=color:#66d9ef>from</span> emp <span style=color:#66d9ef>where</span> sal <span style=color:#f92672>&gt;</span><span style=color:#ae81ff>2000</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- union result:从union表获取结果的select
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>explain</span> <span style=color:#66d9ef>select</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>from</span> emp <span style=color:#66d9ef>where</span> deptno <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span> <span style=color:#66d9ef>union</span> <span style=color:#66d9ef>select</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>from</span> emp <span style=color:#66d9ef>where</span> sal <span style=color:#f92672>&gt;</span><span style=color:#ae81ff>2000</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- subquery:在select或者where列表中包含子查询
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>explain</span> <span style=color:#66d9ef>select</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>from</span> emp <span style=color:#66d9ef>where</span> sal <span style=color:#f92672>&gt;</span> (<span style=color:#66d9ef>select</span> <span style=color:#66d9ef>avg</span>(sal) <span style=color:#66d9ef>from</span> emp) ;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- dependent subquery:subquery的子查询要受到外部表查询的影响
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>explain</span> <span style=color:#66d9ef>select</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>from</span> emp e <span style=color:#66d9ef>where</span> e.deptno <span style=color:#66d9ef>in</span> (<span style=color:#66d9ef>select</span> <span style=color:#66d9ef>distinct</span> deptno <span style=color:#66d9ef>from</span> dept);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- DERIVED: from子句中出现的子查询，也叫做派生类，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>explain</span> <span style=color:#66d9ef>select</span> staname,ename supname <span style=color:#66d9ef>from</span> (<span style=color:#66d9ef>select</span> ename staname,mgr <span style=color:#66d9ef>from</span> emp) t <span style=color:#66d9ef>join</span> emp <span style=color:#66d9ef>on</span> t.mgr<span style=color:#f92672>=</span>emp.empno ;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- UNCACHEABLE SUBQUERY：表示使用子查询的结果不能被缓存
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> <span style=color:#66d9ef>explain</span> <span style=color:#66d9ef>select</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>from</span> emp <span style=color:#66d9ef>where</span> empno <span style=color:#f92672>=</span> (<span style=color:#66d9ef>select</span> empno <span style=color:#66d9ef>from</span> emp <span style=color:#66d9ef>where</span> deptno<span style=color:#f92672>=@@</span>sort_buffer_size);
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#75715e>-- uncacheable union:表示union的查询结果不能被缓存：sql语句未验证
</span></span></span></code></pre></div><h4 id=table>table</h4><ol><li>如果是具体的表名，则表明从实际的物理表中获取数据，当然也可以是表的别名</li><li>表名是derivedN的形式，表示使用了id为N的查询产生的衍生表</li><li>当有union result的时候，表名是union n1,n2等的形式，n1,n2表示参与union的id</li></ol><h4 id=type>type</h4><p><code>system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- all:全表扫描，一般情况下出现这样的sql语句而且数据量比较大的话那么就需要进行优化。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>explain</span> <span style=color:#66d9ef>select</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>from</span> emp;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- index：全索引扫描这个比all的效率要好，主要有两种情况，一种是当前的查询时覆盖索引，
</span></span></span><span style=display:flex><span><span style=color:#75715e>-- 即我们需要的数据在索引中就可以索取，或者是使用了索引进行排序，这样就避免数据的重排序
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>explain</span>  <span style=color:#66d9ef>select</span> empno <span style=color:#66d9ef>from</span> emp;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- range：表示利用索引查询的时候限制了范围，在指定范围内进行查询，
</span></span></span><span style=display:flex><span><span style=color:#75715e>-- 这样避免了index的全索引扫描，适用的操作符： =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, BETWEEN, LIKE, or IN() 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>explain</span> <span style=color:#66d9ef>select</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>from</span> emp <span style=color:#66d9ef>where</span> empno <span style=color:#66d9ef>between</span> <span style=color:#ae81ff>7000</span> <span style=color:#66d9ef>and</span> <span style=color:#ae81ff>7500</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- index_subquery：利用索引来关联子查询，不再扫描全表
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>explain</span> <span style=color:#66d9ef>select</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>from</span> emp <span style=color:#66d9ef>where</span> emp.job <span style=color:#66d9ef>in</span> (<span style=color:#66d9ef>select</span> job <span style=color:#66d9ef>from</span> t_job);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- unique_subquery:该连接类型类似与index_subquery,使用的是唯一索引
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>explain</span> <span style=color:#66d9ef>select</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>from</span> emp e <span style=color:#66d9ef>where</span> e.deptno <span style=color:#66d9ef>in</span> (<span style=color:#66d9ef>select</span> <span style=color:#66d9ef>distinct</span> deptno <span style=color:#66d9ef>from</span> dept);
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#75715e>-- index_merge：在查询过程中需要多个索引组合使用，没有模拟出来
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- ref_or_null：对于某个字段即需要关联条件，也需要null值的情况下，查询优化器会选择这种访问方式
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>explain</span> <span style=color:#66d9ef>select</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>from</span> emp e <span style=color:#66d9ef>where</span>  e.mgr <span style=color:#66d9ef>is</span> <span style=color:#66d9ef>null</span> <span style=color:#66d9ef>or</span> e.mgr<span style=color:#f92672>=</span><span style=color:#ae81ff>7369</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- fulltext：全文索引
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- ref：使用了非唯一性索引进行数据的查找
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>create</span> <span style=color:#66d9ef>index</span> idx_3 <span style=color:#66d9ef>on</span> emp(deptno);
</span></span><span style=display:flex><span><span style=color:#66d9ef>explain</span> <span style=color:#66d9ef>select</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>from</span> emp e,dept d <span style=color:#66d9ef>where</span> e.deptno <span style=color:#f92672>=</span>d.deptno;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- eq_ref：使用唯一性索引进行数据查找
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>explain</span> <span style=color:#66d9ef>select</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>from</span> emp,emp2 <span style=color:#66d9ef>where</span> emp.empno <span style=color:#f92672>=</span> emp2.empno;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- const：这个表至多有一个匹配行，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>explain</span> <span style=color:#66d9ef>select</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>from</span> emp <span style=color:#66d9ef>where</span> empno <span style=color:#f92672>=</span> <span style=color:#ae81ff>7369</span>;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#75715e>-- system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现
</span></span></span></code></pre></div><h4 id=possible_keys>possible_keys</h4><p>这张table可能用的索引，不一定使用了</p><h4 id=key>key</h4><p>实际用到的索引，如果为null，则没有用索引，如果使用了覆盖索引，则会与select重叠</p><h4 id=key_len>key_len</h4><p>表示使用索引的字节长度，不损失精度情况，越短越好</p><h4 id=ref>ref</h4><p>显示哪一列被使用了索引，是一个常数</p><h4 id=rows>rows</h4><p>根据表的统计信息及索引情况，大致的计算需要读取的行数</p><h4 id=extra>extra</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- using filesort:说明mysql无法利用索引进行排序，只能利用排序算法进行排序，会消耗额外的位置
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>explain</span> <span style=color:#66d9ef>select</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>from</span> emp <span style=color:#66d9ef>order</span> <span style=color:#66d9ef>by</span> sal;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- using temporary:建立临时表来保存中间结果，查询完成之后把临时表删除
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>explain</span> <span style=color:#66d9ef>select</span> ename,<span style=color:#66d9ef>count</span>(<span style=color:#f92672>*</span>) <span style=color:#66d9ef>from</span> emp <span style=color:#66d9ef>where</span> deptno <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span> <span style=color:#66d9ef>group</span> <span style=color:#66d9ef>by</span> ename;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- using index:这个表示当前的查询时覆盖索引的，直接从索引中读取数据，
</span></span></span><span style=display:flex><span><span style=color:#75715e>-- 而不用访问数据表。如果同时出现using where 表名索引被用来执行索引键值的查找，
</span></span></span><span style=display:flex><span><span style=color:#75715e>-- 如果没有，表面索引被用来读取数据，而不是真的查找
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>explain</span> <span style=color:#66d9ef>select</span> deptno,<span style=color:#66d9ef>count</span>(<span style=color:#f92672>*</span>) <span style=color:#66d9ef>from</span> emp <span style=color:#66d9ef>group</span> <span style=color:#66d9ef>by</span> deptno <span style=color:#66d9ef>limit</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- using where:使用where进行条件过滤
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>explain</span> <span style=color:#66d9ef>select</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>from</span> t_user <span style=color:#66d9ef>where</span> id <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- using join buffer:使用连接缓存，情况没有模拟出来
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- impossible where：where语句的结果总是false
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>explain</span> <span style=color:#66d9ef>select</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>from</span> emp <span style=color:#66d9ef>where</span> empno <span style=color:#f92672>=</span> <span style=color:#ae81ff>7469</span>;
</span></span></code></pre></div><h3 id=如何应用>如何应用</h3><ul><li>type判断是否有使用索引，尽可能的到达range&lt;type&lt;ref</li><li>ref判断是否用到索引</li><li>extra判断是否覆盖索引、排序是否用到索引</li></ul><h2 id=索引优化>索引优化</h2><h3 id=索引基础>索引基础</h3><p>比如一本书的目录，可以让你快速的找到你感兴趣的内容</p><h4 id=优点>优点</h4><ul><li>减少服务器扫描数据量</li><li>帮助服务器避免排序和临时表</li><li>将随机IO变成顺序IO</li></ul><h4 id=用处>用处</h4><ul><li>快速的找到WHERE字句的行</li><li>优化器会找到最优索引</li><li>如果表具有多列索引，优化器会使用索引的任何最左前缀来找到行</li><li>当有表连接时，，从其他表检索行数据</li><li>找到特定的索引列min和max值</li><li>如果索引和分组时在可用的索引最左前缀上完成的，则对进行排序和分组</li><li>某些情况下，可以查询检索值，无需检索行，如<strong>覆盖索引</strong>的情况</li></ul><h4 id=分类>分类</h4><ul><li>主键索引：PRIMARY KEY</li><li>唯一索引：UNIQUE</li><li>普通索引：NORMAL</li><li>全文索引：FULLTEXT</li><li>组合索引：KEY <code>name</code>(<code>字段1</code>,<code>字段2</code>,<code>字段3</code>)</li></ul><h4 id=一些名词>一些名词</h4><ul><li>回表：比如我们需要查用户信息，通过name去查（name字段列是普通索引），<code>普通索引</code>中的data存储的是<code>主键索ID</code>,<code>主键索引</code>data存放的是<code>数据行</code>，执行器会通过普通索引定位到data后，再拿着ID去<code>主键索引</code>去查用户信息数据行(<strong>最后去主键索引查数据行的行为叫回表</strong>)，遍历2次B+树</li><li>覆盖索引：还是刚刚的例子，如果查询的不是用户信息，而是用户ID（主键ID），去掉上面例子中去主键索引的过程，就是覆盖索引，<strong>因为普通索引data就是用户ID</strong>，遍历1次B+树</li><li>最左匹配：B+树索引是有序的，从左往右递增，而组合索引就是从表的字段的左边字段开始匹配，遇到范围停止匹配</li><li>索引下推：将where后面的条件需要在server层过滤的变为在server层之前过滤完成，交给server层的就是结果集</li></ul><h4 id=索引常用的数据结构>索引常用的数据结构</h4><ul><li>哈希表+链表</li><li>B+树<ul><li>发展历程<ul><li>=>哈希表，查询时间复杂度（O(N)），为了降低时间复杂度人们想到了（logn）-> 二叉树</li><li>=>二叉树（分支倾斜严重）</li><li>=>平衡二叉树（平衡分支耗时）</li><li>=>红黑树（减少平衡距离，降低插入速度）</li><li>&mdash;分割线&mdash;无论怎么优化二叉树，随着时间的推移，树的深度总会越来越深&mdash;分割线&mdash;</li><li>=>B树：<ul><li>每个节点（主键（主键+data）+指针（主键子节点范围））16K</li><li>这样的缺点，节点容量固定条件下，data越大，能存放的指针变小，从而导致索引容纳的数少</li><li><img src=https://i.loli.net/2021/08/19/LSwECruVYlIcgXO.png alt=image-20210818231739010></li></ul></li><li>=>B+树<ul><li>让最终的子节点去存放data，子节点的父节点都是指针</li><li>最底层data之间还通过链表相互连接，方便遍历</li><li><img src=https://i.loli.net/2021/08/19/Em38aGv2XuHoZ9c.png alt=image-20210818231629576></li></ul></li></ul></li></ul></li></ul><h4 id=索引匹配的方式>索引匹配的方式</h4><p>name，age组合索引</p><ul><li>全值匹配：name=‘张三’</li><li>匹配最左前缀：name=‘张三’ AND age=10</li><li>匹配列前缀：name like ‘张%’</li><li>匹配范围值：age>10</li><li>精确匹配某一列+范围匹配：name=‘’ AND age > 10</li><li>只访问索引列：select name,age from user where name=‘张三’ AND age=10(覆盖索引)</li></ul><h3 id=哈希索引>哈希索引</h3><ul><li>结构：哈希表 + 链表</li><li>优点<ul><li>结构非常的紧凑，然后查询很快</li></ul></li><li>缺点<ul><li>哈希索引结构只包含行指针和哈希值，不存储值</li><li>哈希不是顺序存储，无法排序</li><li>不支持分列匹配查找</li><li>只支持等值 =，or查找，不支持范围查找</li><li>冲突严重时，链表特别长耗时，维护耗时</li></ul></li><li>案例<ul><li>比如需要存放一个很长的URL，需求需要通过URL查询</li><li>我们可以通过一些哈希函数，如CRC32</li><li>这样可以减小体积</li></ul></li></ul><h3 id=组合索引>组合索引</h3><ul><li>多列共同组成索引树，where最左使用</li></ul><h3 id=聚族索引和非聚族索引>聚族索引和非聚族索引</h3><ul><li>聚族索引：索引中data=元数据<ul><li>INNODB中的主键索引存放的就是元数据</li></ul></li><li>非聚族索引：索引中data!=元数据，而是元数据的地址<ul><li>如MyISAM存储引擎的B+树，data存放的是元数据的文件地址</li></ul></li></ul><h3 id=覆盖索引>覆盖索引</h3><ul><li>一个索引data中有查询字段的值</li><li>实现方式和存储引擎有关，Momery存储引擎不支持</li><li>优势<ul><li>减少IO，B+索引本就有顺序，在IO密集型范围内，读取一次数据IO减少很多</li><li>聚族索引支持更好，非聚族索引只做地址缓存严重影响性能</li></ul></li></ul><h3 id=细节优化>细节优化</h3><ul><li>单表6个以内索引</li><li>一个索引5个字段内</li><li>根据实际业务优化</li><li>少用表达式，计算放到业务层</li><li>优先主键索引，不会触发回表</li><li>使用前缀索引</li><li>使用索引排序</li><li>union all、in、or都能使用索引，in最好</li><li>范围，&lt;,>，但是后面的字段就无法用索引了</li></ul><h3 id=索引监控>索引监控</h3><ul><li>show status like &lsquo;Handler_read%&rsquo;;</li><li>参数解析<ul><li>Handler_read_first：读取索引第一个条目的次数</li><li>Handler_read_key：通过index获取数据的次数</li><li>Handler_read_last：读取索引最后一个条目的次数</li><li>Handler_read_next：通过索引读取下一条数据的次数</li><li>Handler_read_prev：通过索引读取上一条数据的次数</li><li>Handler_read_rnd：从固定位置读取数据的次数</li><li>Handler_read_rnd_next：从数据节点读取下一条数据的次数</li></ul></li></ul><h3 id=案例>案例</h3><h5 id=预备数据>预备数据</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SET</span> FOREIGN_KEY_CHECKS<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>DROP</span> <span style=color:#66d9ef>TABLE</span> <span style=color:#66d9ef>IF</span> <span style=color:#66d9ef>EXISTS</span> <span style=color:#f92672>`</span>itdragon_order_list<span style=color:#f92672>`</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> <span style=color:#f92672>`</span>itdragon_order_list<span style=color:#f92672>`</span> (
</span></span><span style=display:flex><span>  <span style=color:#f92672>`</span>id<span style=color:#f92672>`</span> bigint(<span style=color:#ae81ff>11</span>) <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span> AUTO_INCREMENT <span style=color:#66d9ef>COMMENT</span> <span style=color:#e6db74>&#39;主键id，默认自增长&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>`</span>transaction_id<span style=color:#f92672>`</span> varchar(<span style=color:#ae81ff>150</span>) <span style=color:#66d9ef>DEFAULT</span> <span style=color:#66d9ef>NULL</span> <span style=color:#66d9ef>COMMENT</span> <span style=color:#e6db74>&#39;交易号&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>`</span>gross<span style=color:#f92672>`</span> double <span style=color:#66d9ef>DEFAULT</span> <span style=color:#66d9ef>NULL</span> <span style=color:#66d9ef>COMMENT</span> <span style=color:#e6db74>&#39;毛收入(RMB)&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>`</span>net<span style=color:#f92672>`</span> double <span style=color:#66d9ef>DEFAULT</span> <span style=color:#66d9ef>NULL</span> <span style=color:#66d9ef>COMMENT</span> <span style=color:#e6db74>&#39;净收入(RMB)&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>`</span>stock_id<span style=color:#f92672>`</span> int(<span style=color:#ae81ff>11</span>) <span style=color:#66d9ef>DEFAULT</span> <span style=color:#66d9ef>NULL</span> <span style=color:#66d9ef>COMMENT</span> <span style=color:#e6db74>&#39;发货仓库&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>`</span>order_status<span style=color:#f92672>`</span> int(<span style=color:#ae81ff>11</span>) <span style=color:#66d9ef>DEFAULT</span> <span style=color:#66d9ef>NULL</span> <span style=color:#66d9ef>COMMENT</span> <span style=color:#e6db74>&#39;订单状态&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>`</span>descript<span style=color:#f92672>`</span> varchar(<span style=color:#ae81ff>255</span>) <span style=color:#66d9ef>DEFAULT</span> <span style=color:#66d9ef>NULL</span> <span style=color:#66d9ef>COMMENT</span> <span style=color:#e6db74>&#39;客服备注&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>`</span>finance_descript<span style=color:#f92672>`</span> varchar(<span style=color:#ae81ff>255</span>) <span style=color:#66d9ef>DEFAULT</span> <span style=color:#66d9ef>NULL</span> <span style=color:#66d9ef>COMMENT</span> <span style=color:#e6db74>&#39;财务备注&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>`</span>create_type<span style=color:#f92672>`</span> varchar(<span style=color:#ae81ff>100</span>) <span style=color:#66d9ef>DEFAULT</span> <span style=color:#66d9ef>NULL</span> <span style=color:#66d9ef>COMMENT</span> <span style=color:#e6db74>&#39;创建类型&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>`</span>order_level<span style=color:#f92672>`</span> int(<span style=color:#ae81ff>11</span>) <span style=color:#66d9ef>DEFAULT</span> <span style=color:#66d9ef>NULL</span> <span style=color:#66d9ef>COMMENT</span> <span style=color:#e6db74>&#39;订单级别&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>`</span>input_user<span style=color:#f92672>`</span> varchar(<span style=color:#ae81ff>20</span>) <span style=color:#66d9ef>DEFAULT</span> <span style=color:#66d9ef>NULL</span> <span style=color:#66d9ef>COMMENT</span> <span style=color:#e6db74>&#39;录入人&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>`</span>input_date<span style=color:#f92672>`</span> varchar(<span style=color:#ae81ff>20</span>) <span style=color:#66d9ef>DEFAULT</span> <span style=color:#66d9ef>NULL</span> <span style=color:#66d9ef>COMMENT</span> <span style=color:#e6db74>&#39;录入时间&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span> (<span style=color:#f92672>`</span>id<span style=color:#f92672>`</span>)
</span></span><span style=display:flex><span>) ENGINE<span style=color:#f92672>=</span>InnoDB AUTO_INCREMENT<span style=color:#f92672>=</span><span style=color:#ae81ff>10003</span> <span style=color:#66d9ef>DEFAULT</span> CHARSET<span style=color:#f92672>=</span>utf8;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> itdragon_order_list <span style=color:#66d9ef>VALUES</span> (<span style=color:#e6db74>&#39;10000&#39;</span>, <span style=color:#e6db74>&#39;81X97310V32236260E&#39;</span>, <span style=color:#e6db74>&#39;6.6&#39;</span>, <span style=color:#e6db74>&#39;6.13&#39;</span>, <span style=color:#e6db74>&#39;1&#39;</span>, <span style=color:#e6db74>&#39;10&#39;</span>, <span style=color:#e6db74>&#39;ok&#39;</span>, <span style=color:#e6db74>&#39;ok&#39;</span>, <span style=color:#e6db74>&#39;auto&#39;</span>, <span style=color:#e6db74>&#39;1&#39;</span>, <span style=color:#e6db74>&#39;itdragon&#39;</span>, <span style=color:#e6db74>&#39;2017-08-28 17:01:49&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> itdragon_order_list <span style=color:#66d9ef>VALUES</span> (<span style=color:#e6db74>&#39;10001&#39;</span>, <span style=color:#e6db74>&#39;61525478BB371361Q&#39;</span>, <span style=color:#e6db74>&#39;18.88&#39;</span>, <span style=color:#e6db74>&#39;18.79&#39;</span>, <span style=color:#e6db74>&#39;1&#39;</span>, <span style=color:#e6db74>&#39;10&#39;</span>, <span style=color:#e6db74>&#39;ok&#39;</span>, <span style=color:#e6db74>&#39;ok&#39;</span>, <span style=color:#e6db74>&#39;auto&#39;</span>, <span style=color:#e6db74>&#39;1&#39;</span>, <span style=color:#e6db74>&#39;itdragon&#39;</span>, <span style=color:#e6db74>&#39;2017-08-18 17:01:50&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> itdragon_order_list <span style=color:#66d9ef>VALUES</span> (<span style=color:#e6db74>&#39;10002&#39;</span>, <span style=color:#e6db74>&#39;5RT64180WE555861V&#39;</span>, <span style=color:#e6db74>&#39;20.18&#39;</span>, <span style=color:#e6db74>&#39;20.17&#39;</span>, <span style=color:#e6db74>&#39;1&#39;</span>, <span style=color:#e6db74>&#39;10&#39;</span>, <span style=color:#e6db74>&#39;ok&#39;</span>, <span style=color:#e6db74>&#39;ok&#39;</span>, <span style=color:#e6db74>&#39;auto&#39;</span>, <span style=color:#e6db74>&#39;1&#39;</span>, <span style=color:#e6db74>&#39;itdragon&#39;</span>, <span style=color:#e6db74>&#39;2017-09-08 17:01:49&#39;</span>);
</span></span></code></pre></div><h5 id=案例一>案例一</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>select</span> <span style=color:#f92672>*</span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>from</span> itdragon_order_list 
</span></span><span style=display:flex><span><span style=color:#66d9ef>where</span> transaction_id <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;81X97310V32236260E&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 通过查看执行计划发现type=all,需要进行全表扫描
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>explain</span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>select</span> <span style=color:#f92672>*</span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>from</span> itdragon_order_list 
</span></span><span style=display:flex><span><span style=color:#66d9ef>where</span> transaction_id <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;81X97310V32236260E&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 优化一、为transaction_id创建唯一索引
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>create</span> <span style=color:#66d9ef>unique</span> <span style=color:#66d9ef>index</span> idx_order_transaID <span style=color:#66d9ef>on</span> itdragon_order_list (transaction_id);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 当创建索引之后，唯一索引对应的type是const，通过索引一次就可以找到结果，普通索引对应的type是ref，表示非唯一性索引赛秒，找到值还要进行扫描，直到将索引文件扫描完为止，显而易见，const的性能要高于ref
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> <span style=color:#66d9ef>explain</span> 
</span></span><span style=display:flex><span> <span style=color:#66d9ef>select</span> <span style=color:#f92672>*</span> 
</span></span><span style=display:flex><span> <span style=color:#66d9ef>from</span> itdragon_order_list 
</span></span><span style=display:flex><span> <span style=color:#66d9ef>where</span> transaction_id <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;81X97310V32236260E&#34;</span>;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span> <span style=color:#75715e>-- 优化二、使用覆盖索引，查询的结果变成 transaction_id,当extra出现using index,表示使用了覆盖索引
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> <span style=color:#66d9ef>explain</span> 
</span></span><span style=display:flex><span> <span style=color:#66d9ef>select</span> transaction_id 
</span></span><span style=display:flex><span> <span style=color:#66d9ef>from</span> itdragon_order_list 
</span></span><span style=display:flex><span> <span style=color:#66d9ef>where</span> transaction_id <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;81X97310V32236260E&#34;</span>;
</span></span></code></pre></div><h5 id=案例二>案例二</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- 创建复合索引
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>create</span> <span style=color:#66d9ef>index</span> idx_order_levelDate <span style=color:#66d9ef>on</span> itdragon_order_list (order_level,input_date);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 创建索引之后发现跟没有创建索引一样，都是全表扫描，都是文件排序
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>explain</span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>select</span> <span style=color:#f92672>*</span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>from</span> itdragon_order_list 
</span></span><span style=display:flex><span><span style=color:#66d9ef>order</span> <span style=color:#66d9ef>by</span> order_level,input_date;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 可以使用force index强制指定索引
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>explain</span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>select</span> <span style=color:#f92672>*</span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>from</span> itdragon_order_list 
</span></span><span style=display:flex><span><span style=color:#66d9ef>force</span> <span style=color:#66d9ef>index</span>(idx_order_levelDate) 
</span></span><span style=display:flex><span><span style=color:#66d9ef>order</span> <span style=color:#66d9ef>by</span> order_level,input_date;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 其实给订单排序意义不大，给订单级别添加索引意义也不大
</span></span></span><span style=display:flex><span><span style=color:#75715e>-- 因此可以先确定order_level的值，然后再给input_date排序
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>explain</span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>select</span> <span style=color:#f92672>*</span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>from</span> itdragon_order_list 
</span></span><span style=display:flex><span><span style=color:#66d9ef>where</span> order_level<span style=color:#f92672>=</span><span style=color:#ae81ff>3</span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>order</span> <span style=color:#66d9ef>by</span> input_date;
</span></span></code></pre></div><h2 id=查询sql优化>查询SQL优化</h2><h3 id=查询慢的原因>查询慢的原因</h3><p><code>网络</code>、<code>CPU</code>、<code>IO</code>、<code>上下文切换</code>、<code>系统调用</code>、<code>生成统计信息</code>、<code>锁等待时间</code></p><h3 id=数据访问优化>数据访问优化</h3><ul><li>在无法避免的大量数据过程中，检查<strong>应用程序</strong>和<strong>mysql服务器</strong>是否在检索大量<strong>无需的字段</strong></li><li>是请求了无关的字段，如下<ul><li>查询不需要的字段</li><li>多表返回了全部列</li><li>总是取出全部列</li><li>重复查询相同的数据</li></ul></li></ul><h3 id=执行过程优化>执行过程优化</h3><p><img src=https://i.loli.net/2021/08/19/NMT7RE85UHnIciP.png alt=image-20210819211421019></p><h4 id=查询缓存>=>查询缓存</h4><p>mysql连接器后尝试去命中缓存，命中返回</p><h4 id=解析sql和预处理分析器>=>解析SQL和预处理：分析器</h4><ul><li>通过关键字将SQL语句进行解析并生成一颗解析树</li><li>mysql解析器将使用mysql语法规则验证和解析查询</li></ul><h4 id=优化sql执行计划优化器>=>优化SQL执行计划：优化器</h4><h5 id=初略统计>初略统计</h5><ul><li>表和索引的页面数、索引个数</li><li>索引和数据行长度</li><li>索引分布情况</li></ul><h5 id=大多情况下会选择错误的执行计划原因如下>大多情况下会选择错误的执行计划，原因如下</h5><ul><li>统计信息不准确：<strong>innodb的MVCC会有过个版本</strong></li><li>执行计划成本估算不等于实际执行成本：<strong>mysql不知道那些数据实际在内存中和磁盘中</strong></li><li>优化器认为的最优的和现实不一样：<strong>基于成本模型，但不是我们认为的最优</strong></li><li>不考虑并发执行的查询</li><li>不考虑不受其控制操作的成本：<strong>比如自定义函数</strong></li></ul><h5 id=优化器策略>优化器策略</h5><ul><li>动态优化：与查询的上下文、取值、索引的函数有关，优化N次</li><li>静态优化：直接优化解析树，只优化一次</li></ul><h5 id=优化器类型>优化器类型</h5><ul><li><p>重新定义关联顺序</p></li><li><p>外连接转化为内连接</p></li><li><p>使用等价代换规则，可以使用一些等价简化的表达式</p></li><li><p>count（）、Min（）、Max（）：索引列不为NULL可以优化这类</p></li><li><p>预估并转化常数表达式，检查到可以是一个常数，即转化为常数</p></li><li><p>覆盖索引扫描，符合‘覆盖索引’条件即用</p></li><li><p>子查询优化：<strong>在某些情况下，子查询会变为缓存</strong></p></li><li><p>等值传播</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>如果两个列的值通过等式关联，那么</span>mysql能够把其中一个列的where条件传递到另一个上<span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>explain</span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>select</span> film.film_id 
</span></span><span style=display:flex><span><span style=color:#66d9ef>from</span> film 
</span></span><span style=display:flex><span><span style=color:#66d9ef>inner</span> <span style=color:#66d9ef>join</span> film_actor <span style=color:#66d9ef>using</span>(film_id) 
</span></span><span style=display:flex><span><span style=color:#66d9ef>where</span> film.film_id <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>500</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>这里使用</span>film_id字段进行等值关联<span style=color:#960050;background-color:#1e0010>，</span>film_id这个列不仅适用于film表而且适用于film_actor表
</span></span><span style=display:flex><span><span style=color:#66d9ef>explain</span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>select</span> film.film_id 
</span></span><span style=display:flex><span><span style=color:#66d9ef>from</span> film 
</span></span><span style=display:flex><span><span style=color:#66d9ef>inner</span> <span style=color:#66d9ef>join</span> film_actor <span style=color:#66d9ef>using</span>(film_id) 
</span></span><span style=display:flex><span><span style=color:#66d9ef>where</span> film.film_id <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>500</span> <span style=color:#66d9ef>and</span> film_actor.film_id <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>500</span>;
</span></span></code></pre></div></li></ul><h5 id=关联查询优化>关联查询优化</h5><ul><li><p>简单关联</p><p><img src=https://i.loli.net/2021/08/19/DCAWgGahUbO8vE2.png alt=image-20210819220411148></p></li><li><p>有索引关联</p><p><img src=https://i.loli.net/2021/08/19/DCAWgGahUbO8vE2.png alt></p></li><li><p>无索引关联</p><p><img src=https://i.loli.net/2021/08/19/DCAWgGahUbO8vE2.png alt></p><p>（1）Join Buffer会缓存所有参与查询的列而不是只有Join的列。
（2）可以通过调整join_buffer_size缓存大小
（3）join_buffer_size的默认值是256K，join_buffer_size的最大值在MySQL 5.1.22版本前是4G-1，而之后的版本才能在64位操作系统下申请大于4G的Join Buffer空间。
（4）使用Block Nested-Loop Join算法需要开启优化器管理配置的optimizer_switch的设置block_nested_loop为on，默认为开启。</p><p><strong>查询optimizer_switch设置情况</strong>：show variables like &lsquo;%optimizer_switch%&rsquo;;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- 案例
</span></span></span><span style=display:flex><span><span style=color:#75715e>-- 查看不同的顺序执行方式对查询性能的影响：
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>explain</span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>select</span> 
</span></span><span style=display:flex><span>film.film_id,
</span></span><span style=display:flex><span>film.title,
</span></span><span style=display:flex><span>film.release_year,
</span></span><span style=display:flex><span>actor.actor_id,
</span></span><span style=display:flex><span>actor.first_name,
</span></span><span style=display:flex><span>actor.last_name 
</span></span><span style=display:flex><span><span style=color:#66d9ef>from</span> film 
</span></span><span style=display:flex><span><span style=color:#66d9ef>inner</span> <span style=color:#66d9ef>join</span> film_actor <span style=color:#66d9ef>using</span>(film_id) 
</span></span><span style=display:flex><span><span style=color:#66d9ef>inner</span> <span style=color:#66d9ef>join</span> actor <span style=color:#66d9ef>using</span>(actor_id);
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>查看执行的成本：</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>show</span> status <span style=color:#66d9ef>like</span> <span style=color:#e6db74>&#39;last_query_cost&#39;</span>; 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 按照自己预想的规定顺序执行：
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>explain</span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>select</span> straight_join 
</span></span><span style=display:flex><span>film.film_id,
</span></span><span style=display:flex><span>film.title,
</span></span><span style=display:flex><span>film.release_year,
</span></span><span style=display:flex><span>actor.actor_id,
</span></span><span style=display:flex><span>actor.first_name,
</span></span><span style=display:flex><span>actor.last_name 
</span></span><span style=display:flex><span><span style=color:#66d9ef>from</span> film 
</span></span><span style=display:flex><span><span style=color:#66d9ef>inner</span> <span style=color:#66d9ef>join</span> film_actor <span style=color:#66d9ef>using</span>(film_id) 
</span></span><span style=display:flex><span><span style=color:#66d9ef>inner</span> <span style=color:#66d9ef>join</span> actor <span style=color:#66d9ef>using</span>(actor_id);
</span></span><span style=display:flex><span><span style=color:#75715e>-- 查看执行的成本：
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>show</span> status <span style=color:#66d9ef>like</span> <span style=color:#e6db74>&#39;last_query_cost&#39;</span>; 
</span></span></code></pre></div></li></ul><h5 id=排序优化>排序优化</h5><p>​ 无论如何排序都是一个成本很高的操作，所以从性能的角度出发，应该尽可能避免排序或者尽可能避免对大量数据进行排序。推荐使用利用索引进行排序，但是当不能使用索引的时候，mysql就需要自己进行排序，如果数据量小则再内存中进行，如果数据量大就需要使用磁盘，mysql中称之为<strong>filesort</strong>。如果需要排序的数据量小于排序缓冲区(<code>show variables like '%sort_buffer_size%';</code>),mysql使用内存进行快速排序操作，如果内存不够排序，那么mysql就会先将树分块，对每个独立的块使用快速排序进行排序，并将各个块的排序结果存放再磁盘上，然后将各个排好序的块进行合并，最后返回排序结果</p><ul><li><p>单次排序</p><p><strong>先读取</strong>查询所需要的所有列，<strong>然后</strong>再根据给定列进行排序，<strong>最后</strong>直接返回排序结果；</p><p>此方式只需要一次顺序IO读取所有的数据，而无须任何的随机IO，问题在于查询的列特别多的时候，会占用大量的存储空间，无法存储大量的数据</p></li><li><p>两次排序</p><p><strong>第一次</strong>数据读取是将需要排序的字段读取出来，然后进行排序；<strong>第二次</strong>是将排好序的结果按照需要去读取数据行。
这种方式效率比较低，原因是第二次读取数据的时候因为已经排好序，需要去读取所有记录而此时更多的是随机IO，读取数据成本会比较高
两次传输的优势，在排序的时候存储尽可能少的数据，让排序缓冲区可以尽可能多的容纳行数来进行排序操作</p></li></ul><p>当需要排序的列的总大小超过**<code>max_length_for_sort_data</code>**定义的字节，mysql会选择双次排序，反之使用单次排序，当然，用户可以设置此参数的值来选择排序的方式</p><h3 id=执行器>=>执行器</h3><h3 id=特定类型查询优化>特定类型查询优化</h3><h4 id=优化count>优化COUNT()</h4><ul><li>MYISAM存储引擎在没有where的条件下count(*)最快</li><li>近视值，通过EXPLAIN的row取值</li><li>更复杂优化，考虑覆盖索引扫描或者增加汇总表</li></ul><h4 id=优化关联查询>优化关联查询</h4><ul><li>确保ON后者using字句中有索引，考虑顺序</li><li>group by和order by中的表达式中涉及一个表中的列相同排序方式才会用到索引</li></ul><h4 id=优化子查询>优化子查询</h4><ul><li>尽可能通过关联查询代替</li></ul><h4 id=优化limit查询>优化Limit查询</h4><ul><li>在很多应用场景中我们需要将数据进行分页，<strong>一般会使用limit加上偏移量的方法实现，同时加上合适的orderby 的子句</strong>，如果这种方式有索引的帮助，效率通常不错，否则的化需要进行大量的文件排序操作，</li><li>还有一种情况，当偏移量非常大的时候，前面的大部分数据都会被抛弃，这样的代价太高，要优化这种查询的话，<strong>要么是在页面中限制分页的数量，要么优化大偏移量的性能</strong></li></ul><h4 id=优化union查询>优化union查询</h4><ul><li>mysql总是通过创建并填充临时表的方式来执行union查询，因此很多优化策略在union查询中都没法很好的使用。</li><li>经常需要<strong>手工的将where、limit、order by等子句下推到各个子查询中</strong>，<strong>以便优化器可以充分利用这些条件进行优化</strong></li></ul><h4 id=用户自定义变量>用户自定义变量</h4><ul><li><p>在查询中混合使用过程化和关系话逻辑的时候，自定义变量会非常有用；用户自定义变量是一个用来存储内容的临时容器，在连接mysql的整个过程中都存在。</p></li><li><p>自定义变量使用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>set</span> <span style=color:#f92672>@</span>one :<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>set</span> <span style=color:#f92672>@</span>min_actor :<span style=color:#f92672>=</span>(<span style=color:#66d9ef>select</span> <span style=color:#66d9ef>min</span>(actor_id) <span style=color:#66d9ef>from</span> actor)
</span></span><span style=display:flex><span><span style=color:#66d9ef>set</span> <span style=color:#f92672>@</span>last_week :<span style=color:#f92672>=</span><span style=color:#66d9ef>current_date</span><span style=color:#f92672>-</span>interval <span style=color:#ae81ff>1</span> week;
</span></span></code></pre></div></li><li><p>自定义变量的限制</p><ol><li>无法使用查询缓存</li><li>不能在使用常量或者标识符的地方使用自定义变量，例如表名、列名或者limit子句</li><li>用户自定义变量的生命周期是在一个连接中有效，所以不能用它们来做连接间的通信</li><li>不能显式地声明自定义变量地类型</li><li>mysql优化器在某些场景下可能会将这些变量优化掉，这可能导致代码不按预想地方式运行</li><li>赋值符号：=的优先级非常低，所以在使用赋值表达式的时候应该明确的使用括号</li><li>使用未定义变量不会产生任何语法错误</li></ol></li><li><p>使用案例</p><ul><li><p>优化排名</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- 1、在给一个变量赋值的同时使用这个变量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>select</span> actor_id,<span style=color:#f92672>@</span>rownum:<span style=color:#f92672>=@</span>rownum<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span> <span style=color:#66d9ef>as</span> rownum 
</span></span><span style=display:flex><span><span style=color:#66d9ef>from</span> actor 
</span></span><span style=display:flex><span><span style=color:#66d9ef>limit</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>-- 2、查询获取演过最多电影的前10名演员
</span></span></span><span style=display:flex><span><span style=color:#75715e>-- 然后根据出演电影次数做一个排名
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>select</span> actor_id,<span style=color:#66d9ef>count</span>(<span style=color:#f92672>*</span>) <span style=color:#66d9ef>as</span> cnt 
</span></span><span style=display:flex><span><span style=color:#66d9ef>from</span> film_actor 
</span></span><span style=display:flex><span><span style=color:#66d9ef>group</span> <span style=color:#66d9ef>by</span> actor_id <span style=color:#66d9ef>order</span> <span style=color:#66d9ef>by</span> cnt <span style=color:#66d9ef>desc</span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>limit</span> <span style=color:#ae81ff>10</span>;
</span></span></code></pre></div></li><li><p>避免重新查询更新值</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- 当需要高效的更新一条记录的时间戳，同时希望查询当前记录中存放的时间戳是什么
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 分开写法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>update</span> t1 <span style=color:#66d9ef>set</span>  lastUpdated<span style=color:#f92672>=</span>now() <span style=color:#66d9ef>where</span> id <span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>select</span> lastUpdated <span style=color:#66d9ef>from</span> t1 <span style=color:#66d9ef>where</span> id <span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 自定义变量写法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>update</span> t1 <span style=color:#66d9ef>set</span> lastupdated <span style=color:#f92672>=</span> now() 
</span></span><span style=display:flex><span><span style=color:#66d9ef>where</span> id <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>and</span> <span style=color:#f92672>@</span>now:<span style=color:#f92672>=</span>now();
</span></span><span style=display:flex><span><span style=color:#66d9ef>select</span> <span style=color:#f92672>@</span>now;
</span></span></code></pre></div></li><li><p>确定取值顺序</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- 在赋值和读取变量的时候可能是在查询的不同阶段
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>set</span> <span style=color:#f92672>@</span>rownum:<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>select</span> actor_id,<span style=color:#f92672>@</span>rownum:<span style=color:#f92672>=@</span>rownum<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span> <span style=color:#66d9ef>as</span> cnt 
</span></span><span style=display:flex><span><span style=color:#66d9ef>from</span> actor <span style=color:#66d9ef>where</span> <span style=color:#f92672>@</span>rownum<span style=color:#f92672>&lt;=</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>-- 因为where和select在查询的不同阶段执行，所以看到查询到两条记录，这不符合预期
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>set</span> <span style=color:#f92672>@</span>rownum:<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>select</span> actor_id,<span style=color:#f92672>@</span>rownum:<span style=color:#f92672>=@</span>rownum<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span> <span style=color:#66d9ef>as</span> cnt 
</span></span><span style=display:flex><span><span style=color:#66d9ef>from</span> actor 
</span></span><span style=display:flex><span><span style=color:#66d9ef>where</span> <span style=color:#f92672>@</span>rownum<span style=color:#f92672>&lt;=</span><span style=color:#ae81ff>1</span> <span style=color:#66d9ef>order</span> <span style=color:#66d9ef>by</span> first_name
</span></span><span style=display:flex><span><span style=color:#75715e>-- 当引入了order by之后，发现打印出了全部结果，
</span></span></span><span style=display:flex><span><span style=color:#75715e>-- 这是因为order by引入了文件排序，而where条件是在文件排序操作之前取值的  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 解决这个问题的关键在于让变量的赋值和取值发生在执行查询的同一阶段：
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>set</span> <span style=color:#f92672>@</span>rownum:<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>select</span> actor_id,<span style=color:#f92672>@</span>rownum <span style=color:#66d9ef>as</span> cnt 
</span></span><span style=display:flex><span><span style=color:#66d9ef>from</span> actor <span style=color:#66d9ef>where</span> (<span style=color:#f92672>@</span>rownum:<span style=color:#f92672>=@</span>rownum<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)<span style=color:#f92672>&lt;=</span><span style=color:#ae81ff>1</span>;
</span></span></code></pre></div></li></ul></li></ul></section><footer class="mt-12 flex flex-wrap"><a class="mb-1.5 mr-1.5 rounded-lg bg-black/[3%] px-5 py-1.5 no-underline dark:bg-white/[8%]" href=https://blog.codingforjoy.com/tags/mysql>Mysql</a>
<a class="mb-1.5 mr-1.5 rounded-lg bg-black/[3%] px-5 py-1.5 no-underline dark:bg-white/[8%]" href=https://blog.codingforjoy.com/tags/%E8%B0%83%E4%BC%98>调优</a></footer><div class=mt-24 id=disqus_thread></div><script>const disqusShortname="YOUR_DISQUS_SHORTNAME",script=document.createElement("script");script.src="https://"+disqusShortname+".disqus.com/embed.js",script.setAttribute("data-timestamp",+new Date),document.head.appendChild(script)</script><div class=mt-24 id=graphcomment></div><script type=text/javascript>var __semio__params={graphcommentId:"YOUR_GRAPH_COMMENT_ID",behaviour:{}};function __semio__onload(){__semio__gc_graphlogin(__semio__params)}(function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.onload=__semio__onload,e.defer=!0,e.src="https://integration.graphcomment.com/gc_graphlogin.js?"+Date.now(),(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)})()</script><div class="giscus mt-24"></div><script src=https://giscus.app/client.js data-repo=YOUR_GISCUS_REPO data-repo-id=YOUR_GISCUS_REPO_ID data-category=YOUR__GISCUS_CATEGORY data-category-id=YOUR_GISCUS_CATEGORY_ID data-mapping=pathname data-strict=1 data-reactions-enabled=0 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><footer class="opaco mx-auto flex h-[4.5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"><div class=mr-auto>&copy; 2024
<a class=link href=https://blog.codingforjoy.com/>Home</a></div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>Powered by Hugo️️</a>️
<a class=link href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>✎ Paper</a></footer></body></html>